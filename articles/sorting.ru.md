# Сортировка в Perl

## Введение

Каждый программист сталкивается с задачей упорядочения массивов данных.
Иногда по пять раз еще до завтрака. Упорядочивать списки приходится часто и много.
Хорошо, если данные сразу приходят упорядоченными из внешнего источника (базы данных, файловой системы и т.п.),
если нет — тоже не страшно, можно и в собственной программе отсортировать.

Существует несколько десятков алгоритмов сортировки. Почтенный дедушка Дональд Кнут
написал о них эпохальный труд сорок лет назад. Самые удачные алгоритмы всем известны
и «прошиты» в языки программирования и стандартные библиотеки.

В perl тоже есть встроенная функция сортировки. Называется [`sort`](http://perldoc.perl.org/functions/sort.html).
Работает в списковом контексте, принимает неупорядоченный список, возвращает упорядоченный.

    my @sorted = sort @unsorted;
    
На этом, кажется, можно было бы закончить.

## Основы

Какой алгоритм сортировки у perl под капотом, программисту знать не обязательно
(хотя есть <a href="#a-use-sort">способ узнать</a> и даже повлиять).

В свою очередь, универсальные алгоритмы сортировки не требуют
никакого особого знания о предметах, которые они сортируют.
Достаточно только двух функций: *сравнить* два элемента и *переставить* их местами.
Как переставлять элементы, интерпретатор perl сам отлично знает, а вот насчет *сравнить* может и вас послушать.



## Функция сравнения

Четыре наиболее популярных функции сравнения:

    { $a <=> $b }
    { $b <=> $a }
    { $a cmp $b }
    { $b cmp $a }

заменяются на встроенный код, выполняющийся очень быстро.
Этот факт используется в <a href="#a-grt">преобразовании Гаттмана-Рослера</a>.

> Иногда можно встретить замечание, что
> 
>     reverse sort { $a <=> $b } @list
>     
> выполняется быстрее, чем
> 
>     sort { $b <=> $a } @list
> 
> В современных версиях perl это не так. Не используйте `reverse` для изменения порядка сортировки.

Функция сравнения должна возвращать число, меньшее, большее или равное нулю, в зависимости от того,
как переменные `$a` и `$b` связаны отношением порядка. Но даже встроенные функции не всегда соблюдают это требование:
операция численного сравнения `<=>` возвращает `undef`, если один из аргументов NaN, «не-число». Поэтому избегайте
списков, содержащих NaN, результат их сортировки будет неопределенным. Очистить список можно так:

    @clean = grep { $_ == $_ } @nans;
     

## Сортировка по нескольким полям



## Манёвр орка (Orcish Maneuver, OM)

Бывает, что ключ сортировки вычисляется сложной или недетерминированной функцией,
или даже внешней функцией (*XSUB*). Популярный пример — сортировка списка файлов
по времени модификации. Очевидная реализация:

    sort {-M $a <=> -M $b} @files;

имеет два недостатка: во-первых, функция `stat` будет вызвана столько раз,
сколько потребуется сравнений, то есть *O*(*n* log *n*).
Во-вторых, между вызовами функции файл может быть изменен, получив новое значение
в качестве ключа.

    my %mod_times;
    my @sorted = sort {
        ( $mod_times{$a} ||= -M $a ) <=>
        ( $mod_times{$b} ||= -M $b )
    } @files;
    
Недостаток: если значение в кэше сводится к ложному значению, ключ вычисляется повторно.

    my @sorted = sort {
        $mod_times{$a} = -M $a if not exists $mod_times{$a};
        $mod_times{$b} = -M $b if not exists $mod_times{$b};
        $a <=> $b
    } @files;

> Название идиомы происходит от созвучия слов «or» и «cache» со словом «Orcish».

## Преобразование Шварца (Schwartzian transform, ST)

Добиться вычисления ключа только один раз для каждого элемента можно следующим образом:

1. Добавим к элементам исходного списка значение вычисленного ключа, например, построим новый
список с элементами-кортежами вида `[item, sortkey]`, которые содержат ссылку на собственно элемент и ключ сортировки.
1. Упорядочим новый список по второму значению.
1. Извлечем из упорядоченного списка исходные элементы в полученном порядке.

Perl позволяет лаконично записать такое преобразование с использованием анонимных списков:

    my @sorted = map  { $_->[0] }
                 sort { $a->[1] <=> $b->[1] }
                 map  { [$_, -M] }
                      @files;
                 
Эта идиома программирования названа в честь Рэндала Л. Шварца, соавтора многих книг о perl
(в частности, легендарной «[Lama book](http://shop.oreilly.com/product/0636920018452.do)»).
Рэндал Шварц продемонстрировал её в 1994 году, вскоре после выхода Perl 5.

> Справедливости ради заметим, что метод был известен и ранее, в других языках,
> как идиома «*decorate-sort-undecorate*», а название «*Schwartzian transform*»
> применяется в основном в perl-практике.

Ключ будет вычислен ровно `N` раз для списка из `N` элементов. Отсюда следует,
что если множество значений ключей заметно меньше `N`, то метод OM может оказаться 

## <a name="a-grt">Преобразование Гаттмана-Рослера</a> (Guttman Rosler Transform, GRT)

Вызов пользовательской функции сравнения достаточно дорог, а обычное численное или
лексикографическое сравнение выполняется очень быстро. Метод оптимизации, предложенный
perl-хакерами Uri Guttman и Larry Rosler, заключается в преобразовании
элементов сортируемого списка таким образом, чтобы их сравнение выполнялось встроенными
функциями.

Допустим, исходный список представляет собой набор кортежей-троек целых чисел
в диапазоне от 0 до 99 включительно, и упорядочить его нужно сначала по первым числам,
затем по вторым и т.д. Сортировка с пользовательской функцией сравнения:

    my @sorted = sort {
        $a->[0] <=> $b->[0] || 
        $a->[1] <=> $b->[1] || 
        $a->[2] <=> $b->[2] 
    } @triplets;

Воспользуемся тем фактом, что числа укладываются в два десятичных разряда, и составим из троек
целые числа в диапазоне `[ 0 .. 999_999 ]` (новый диапазон помещается в машинное целое).
Затем отсортируем полученные числа обычным численным сравнением `$a <=> $b` — несмотря на то,
что код выглядит тоже как пользовательская функция, perl будет использовать встроенный метод сравнения чисел.
Наконец, разобъем числа на тройки по двум цифрам, вернув исходное представление:

    my @sorted = map  { $x = int($_ / 100**2); $y = int($_ / 100) - $x * 100; $z = $_ % 100; [ $x, $y, $z ]; }
                 sort { $a <=> $b }
                 map  { $_->[0] * 100**2 + $_->[1] * 100 + $_->[2] }
                      @triplets;
                      
На массивах из ста тысяч элементов можно получить выигрыш в скорости выполнения более чем в два раза.

Второй вариант — преобразовать тройки чисел в строки длиной три байта, и упорядочить их лексикографически:

    my @sorted = map  { [ unpack "C3", $_ ] }
                 sort
                 map  { pack "C3", @$_ }
                      @triplets;

Для упаковки сортируемых объектов в числа или строки можно придумать множество методов:

- запись в битовые поля
- арифметическое кодирование
- формирование строк фиксированной длины (*padding*)
- формирование строк с разделителями, например, нулевыми байтами

Здесь будут полезны функции `sprintf`, `pack`, `join`, регулярные выражения.
При сериализации чисел в строку не забывайте выравнивать их по правому краю, дополняя нулями или
пробелами, и использовать фиксированное число знаков после точки.
Побитовое отрицание над строками удобно, чтобы изменить порядок сортировки на обратный.

Сериализация и десериализация данных — зачастую довольно дорогие операции. Насколько эффективным будет GRT,
зависит от способа сериализации, от сложности функции сравнения и от отношения количества сравнений
к количеству преобразований данных. Можно ускорить сортировку на порядок, можно и наоборот, потерять в скорости.
Обязательно протестируйте несколько вариантов упаковки объектов на данных, максимально приближенных к реальным.
Пример скрипта с тестированием производительности на Github: [sorting-grp.pl](https://github.com/alistratov/...)

## Модули CPAN

- [Sort::Maker](http://search.cpan.org/perldoc?Sort%3A%3AMaker)
- [Sort::MultipleFields](http://search.cpan.org/perldoc?Sort%3A%3AMultipleFields)
- [Sort::Fields](http://search.cpan.org/perldoc?Sort%3A%3AFields)
- [Sort::Key](http://search.cpan.org/perldoc?Sort%3A%3AKey)
- [Sort::XS](http://search.cpan.org/perldoc?Sort%3A%3AXS)

## <a name="a-use-sort">Выбор алгоритма сортировки</a>

Начиная с версии 5.8, perl может использовать два алгоритма сортировки:
[mergesort](http://en.wikipedia.org/wiki/Merge_sort) — сортировку слиянием,
и [quicksort](http://en.wikipedia.org/wiki/Quicksort) — быструю сортировку.

В большинстве случаев выгоднее алгоритм mergesort: он имеет гарантированную сложность *O*(*n* log *n*),
в то время как quicksort деградирует до квадратичной сложности в худших случаях, и он *устойчив*,
то есть сохраняет исходный порядок элементов, равных по ключу сравнения.

Однако иногда может быть полезнее quicksort, который использует меньше памяти и быстрее сортирует списки,
содержащие небольшое количество уникальных элементов (то есть списки, имеющие высокую, плохую
selectivity в терминах реляционных баз данных).

Вы можете указать предпочитаемый алгоритм директивой (прагмой) [`sort`](http://search.cpan.org/perldoc?sort),
например, потребовать, чтобы обязательно использовался устойчивый алгоритм:

    use sort qw(stable);
    
Директива действует в лексической области видимости.

-

http://www.misc-perl-info.com/perl-sort.html
http://www.sysarch.com/Perl/sort_paper.html
http://raleigh.pm.org/sorting.html
https://metacpan.org/module/URI/Sort-Maker-0.06/Sort/Maker.pm#ST
http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F
http://en.wikipedia.org/wiki/Schwartzian_transform
http://www.nntp.perl.org/group/perl.beginners/2001/05/msg1250.html

http://koorchik.blogspot.ru/2011/03/guttman-rosler-transform-1.html
http://www.perlmonks.org/?node=130021
http://www.nntp.perl.org/group/perl.beginners/2001/05/msg1250.html
http://www.perlmonks.org/?node_id=145659

cmp use local

XSUB does not use $a $b, prototyped func also.
